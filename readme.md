# Подбор наиболее частный вопросов на собеседования для фронтэнда с ответами, чтобы освежить память (Part 2)

Пулреквесты с доп. вопросами и ответами приветствуются! Составленно на основе личного опыта прохождения собеседований, а так же с простор интернета.

<div>
	<p>Первая часть: https://github.com/yofi2tofi/frontend-questions-with-answers</p>
</div>

<div>
	<p>https://github.com/vasanthk/css-refresher-notes</p>
	<p>https://habrahabr.ru/post/273471/</p>
</div>

## Вопросы по CSS

<details>
<summary>Расскажите о блочной модели CSS</summary>
<div> 
	<br />
	<p>Блочная модель CSS – это прямоугольное пространство вокруг элемента HTML, в котором определяются границы, поля и отступы.</p>
	<p>Границы – определяют максимальную область, в которой будет содержаться элемент. Мы можем сделать границу видимой, невидимой, определить высоту и ширину элемента и т.п. Поля – определяют расстояния между границами и элементом.</p>
	<p>Отступы – определяют расстояния между границами и соседними элементами.</p>
</div>
</details>

<details>
<summary>Что такое "reset" CSS и для чего он нужен?</summary>
<div> 
	<br />
	<p>Каждый браузер устанавливает свои значения стилей по умолчанию для различных HTML-элементов. С помощью CSS Reset мы можем нивелировать эту разницу для обеспечения кроссбраузерности стилей.</p>
	<p>Например, вы используете элемент a в вашем документе. Большинство браузеров, как Internet Explorer и Firefox, добавляют ссылке синий цвет и подчёркивание. Однако представьте, что через пять лет кто-то решил создать новый браузер (назовём его UltraBrowser). Разработчикам браузера не нравился синий цвет и раздражало подчёркивание, поэтому они решили выделять ссылки красным цветом и полужирным шрифтом. Именно исходя из этого, если вы установите базовое значение стилей для элемента a, то он гарантированно будет таким, каким вы хотите его видеть, а не как предпочитают его отображать разработчики UltraBrowser.</p>
	<p>Подробней: https://habrahabr.ru/post/45296/</p>
</div>
</details>

<details>
<summary>Что такое "normalize" CSS и для чего он нужен?</summary>
<div> 
	<br />
	<p>Normalize.css является альтернативой CSS Reset. Проект является продуктом сотен часов глубокого исследования различий между изначальными стилями браузера. Это исследование провели Николас Галахер и Джонатан Нил.</p>
	<b>Цели normalize.css:</b>
	<ul>
		<li>сохранять полезные настройки браузера, а не стирать их;</li>
		<li>нормализовать стили для широкого круга HTML-элементов;</li>
		<li>корректировать ошибки и основные несоответствия браузера;</li>
		<li>совершенствовать юзабилити незаметными улучшениями;</li>
		<li>объяснять код, используя комментарии и детальную документацию.</li>
	</ul>
	<p>Он поддерживает широкий диапазон браузеров (в том числе мобильных) и включает в себя CSS, который нормализует HTML5-элементы, типографику, списки, встраиваемый контент, формы и таблицы.</p>
	<p>Несмотря на то, что проект основан на принципе нормализации, он использует стандартные настройки там, где они предпочтительны.</p>
	<b>Подробней: </b>
	<ul>
		<li>https://htmlacademy.ru/blog/64-about-normalize-css</li>
		<li>https://habrahabr.ru/company/htmlacademy/blog/342052/</li>
	</ul>
</div>
</details>

<details>
<summary>Чем отличается reset.css от normalize.css?</summary>
<div> 
	<br />
	<p>Reset.css накладывает однородный визуальный стиль, выравнивая стили по умолчанию почти для всех элементов. В отличие от этого, normalize.css сохраняет многие полезные стили браузеров по умолчанию. Это значит, что не требуется повторно объявлять стили для всех стандартных элементов типографики.</p>
	<p>Когда элемент имеет различные стили по умолчанию в разных браузерах, normalize.css там, где это возможно, стремится сделать эти стили совместимыми и соответствующими современными стандартам.</p>
	<p>Подробней: https://htmlacademy.ru/blog/64-about-normalize-css</p>
</div>
</details>

<details>
<summary>Объясните, что такое плавающие элементы (floats) и как они работают?\*</summary>
<div> 
	<br />
	<ul>
		<li>Float определяет, по какой стороне будет выравниваться элемент, при этом остальные элементы будут обтекать его с других сторон. Плавающие (обтекающие) элементы сначала выстраиваются в нормальном потоке, затем образуется новый поток, и они сдвигаются либо вправо, либо влево (в зависимости от выбранного значения) в родительском контейнере. Иными словами, они идут по порядку друг за другом. Учитывая, что в родительском контейнере есть достаточно свободного места, эти плавающие элементы не подстраиваются и не выравниваются для распределения пространства между этими самыми элементами.</li>
		<li>Как правило, плавающий элемент обязательно должен иметь фиксированную ширину. Это гарантирует, что float ведет себя так как и ожидалось, избегая проблем в некоторых браузерах.</li>
		<li>Используя свойство clear, вы можете указать пять значений: left, right, both, inherit, и none. Это свойство определяет, по какой стороне будет выравниваться элемент, при этом остальные элементы будут обтекать его с других сторон. Например, если вы укажите «left», элемент задействует отмену обтекания с левого края плавающего элемента. При этом все другие элементы на этой стороне будут опущены вниз, и располагаться под текущим элементом.</li>
		<li>Правило, которое я обнаружил для себя, прекрасно работает для моих float-макетов.В своем HTML коде, я почти всегда сначала создаю плавающие элементы во время разметки, прежде чем добавлять простые элементы, которые могут взаимодействовать с ними. Вы экономите большую часть времени, и это дает желаемый результат.</li>
		<li>Но и тут бывают проблемы, когда вы помещаете в родительский блок плавающие элементы, родительский контейнер не может определить динамически высоту своих дочерних элементов, поэтому родительский контейнер будет иметь высоту равную нулю. Это может поломать вашу верстку. Существует метод, который позволяет родительскому элементу, определить свое пространство с учетом каких-либо плавающих элементов внутри. Можно использовать CSS свойство overflow (переполнение) со значением hidden (скрыть). Обратите внимание, что значение свойства overflow не предназначено для такого рода использования, и может вызывать некоторые проблемы, такие как скрытие нужного контента в данный момент или появление нежелательных полос прокрутки.</li>
		<li>Хак: для очистки плавающих элементов лучше применять ‘overflow:auto’ к родительскому элементу.</li>
		<li>Обратите внимание, что данный трюк не очищает плавающие элементы — он просто растягивает родительский контейнер. Вы можете принудительно очистить float, если вы добавите очищающий элемент после последнего плавающего элемента, или вы можете добавить в любом нужном вам месте, создав тем самым новый поток. Родительский элемент не умеет очищать дочерние плавающие элементы.</li>
	</ul>
	<b>9 правил:</b>
	<ul>
		<li>Плавающие элементы прижимаются к границам своих контейнеров, но не дальше.</li>
		<li>Любой плавающий элемент будет находится либо рядом, либо ниже предыдущего элемента. Если элементы прижаты влево, второй элемент появится точно справа от первого. Если они прижаты вправо, второй элемент появится слева от первого (reverse).</li>
		<li>Элемент с левым обтеканием, не может быть правее, чем элемент с правым обтеканием.</li>
		<li>Плавающие элементы не могут подняться выше верхнего края родительского контейнера (однако становится еще сложнее, когда задействованы отступы).</li>
		<li>Плавающий элемент не может быть выше своего соседа плавающего элемента.</li>
		<li>Плавающий элемент не может быть выше своего соседа строчного элемента.</li>
		<li>Плавающий элемент совместно со своим таким же соседом элементом, не могут выходить за края родительского контейнера.</li>
		<li>Плавающий элемент должен быть помещен как можно выше.</li>
		<li>Элемент с левым обтеканием должен быть помещен как можно дальше влево, как это возможно, элемент с правым обтеканием должен быть помещен как можно дальше вправо, как это возможно.</li>
	</ul>
	<p>Подробней: https://habrahabr.ru/post/273471/</p>
</div>
</details>

<details>
<summary>Какие вы знаете методы запрета обтекания (clearing) и какие где применяются?</summary>
<div> 
	<br />
	<p>Хак: для очистки плавающих элементов лучше применять ‘overflow:auto’ к родительскому элементу.</p>
</div>

```css
.clearfix:after {
  content: "";
  display: table;
  clear: both;
}
```

</details>

## Вопросы по javascript

<details>
<summary>Что такое web workers и зачем они нужны?</summary>
<div> 
	<br />
	<p>В процессе</p>
</div>
</details>

<details>
<summary>Какие ограничения накладываются на поток Web Worker?</summary>
<div> 
	<br />
	<p>Потоки web worker не могут изменять HTML элементы, глобальные переменные и некоторые свойства окон, такие как window.location. Вы можете использовать типы данных javascript, вызовы XMLHttpRequest и прочее.</p>
</div>
</details>

<details>
<summary>Как создать поток web worker в JavaScript?</summary>
<div> 
	<br />
	<p>В процессе</p>
</div>
</details>

<details>
<summary>Как уничтожить объект web worker?</summary>
<div> 
	<br />
	<p>w.terminate();</p>
</div>
</details>

<details>
<summary>Зачем в HTML 5 введены события server-sent?</summary>
<div> 
	<br />
	<p>В процессе</p>
</div>
</details>
